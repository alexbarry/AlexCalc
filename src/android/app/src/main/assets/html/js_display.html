<!doctype html>
<html>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <!--<script id="MathJax-script" async src="node_modules/mathjax/es5/tex-svg-full.js"></script>-->
    <script src="node_modules/@babel/polyfill/dist/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="node_modules/mathjax/es5/tex-chtml-full.js"></script>
    <style>
        h1 {
            text-align:center;
        }

        .err_msg {
            color: #ff0000;
        }

        .calc_light {
            background-color:#fff;
            color:#000;
        }

        .calc_dark {
            background-color:#222;
            color:#fff;
        }

        .calc_very_dark {
            background-color:#000;
            color:#888;
        }
    </style>
</head>
<body id="calc_body">
<h1>AlexCalc</h1>
<div id="output_text">
</div>
<p id="input_wip_display"></p>
<script>
        window.MathJax = {
            chtml: {
                displayAlign: 'left',
            },
            /* Not sure if I should have this */
            svg: {
                fontCache: 'global',
            }
        };

        function generate_latex_node(tex) {
            var options = {
                //display: true,
                scale: 2.0,
                //containerWidth: 400,
                //lineWidth: 21,
            };

            // without this step, the stylesheet generated by MathJax.chtmlStylesheet()
            // will contain everything for all elements that have been created
            // until the cache was last cleared
            //MathJax.startup.output.clearCache();
            var elem = MathJax.tex2chtml(tex, options);
            // without this step, symbols that haven't been loaded yet don't appear
            var stylesheet = MathJax.chtmlStylesheet();
            //document.head.appendChild(stylesheet);
            return { elem: elem, stylesheet: stylesheet};
        }

		function add_latex_node_to_parent_promise(tex, arg_parent) {
			MathJax.texReset();
			var options = MathJax.getMetricsFor(arg_parent);
			options.scale = 2.0;
			return MathJax.tex2chtmlPromise(tex, options).then( (node) => {
					arg_parent.appendChild(node);
					MathJax.startup.document.clear();
					MathJax.startup.document.updateDocument();
			});
		}

        var output_stylesheets = [];
        var output_elems = [];

        var wip_stylesheets = [];
        var wip_elems = [];

        // Note this includes tex inputs, tex outputs, and error messages.
        const MAX_ELEMS = 20;

        var output_text_window = document.getElementById("output_text");
        
        function add_output_line_tex(tex) {
            console.debug("add_output_line_tex: " + tex);

			// TODO why doesn't this work anymore???
/*
            var output = generate_latex_node(tex);
            output_elems.push({ elem: output.elem, stylesheets: [output.stylesheet]});
            output_text_window.appendChild(output.elem);
            document.head.appendChild(output.stylesheet);
*/
			add_latex_node_to_parent_promise(tex, output_text_window).then( () => {
				remove_output_display_elems(MAX_ELEMS);
				scroll_to_bottom();
			});
        }

        function add_output_line_txt(msg, is_err) {
            console.debug("add_output_line_txt: ", msg, "is_err", is_err);
            var msg_elem = document.createElement("p");
            msg_elem.innerText = msg;
            if (is_err) {
                msg_elem.classList.add("err_msg");
            }
            output_elems.push({ elem: msg_elem, stylesheets: []} );
            output_text_window.appendChild(msg_elem);
            remove_output_display_elems(MAX_ELEMS);
            scroll_to_bottom();
        }

        function add_output_line_err(msg) {
            add_output_line_txt(msg, /* is_err */ true);
        }

        function add_output_line_msg(msg) {
            add_output_line_txt(msg, /* is_err */ false);
        }

        function clear_output_display() {
            remove_output_display_elems(0);
        }


        function remove_output_display_elems(keep_count) {
            while (output_elems.length > keep_count) {
                var info = output_elems.shift();
                for (var stylesheet of info.stylesheets) {
                    document.head.removeChild(stylesheet);
                }
                output_text_window.removeChild(info.elem);
            }

            // There shouldn't be any children now that I'm doing the above way.
            /*
            while (output_text_window.firstChild) {
                output_text_window.removeChild(output_text_window.firstChild);
            }
            */
        }

        function edit_last_output_line_tex(tex) {
            output_text_window.removeChild(output_text_window.lastChild);
            add_output_line_tex(tex);
        }

        function update_wip_tex(tex) {
            console.debug("update_wip_tex", tex);
            const input_wip_display = document.getElementById("input_wip_display");

            clear_wip_tex();

			// TODO why doesn't this work anymore???
			/*
            var output = generate_latex_node(tex);
            wip_stylesheets.push(output.stylesheet);
            wip_elems.push(output.elem);
            input_wip_display.appendChild(output.elem);
            document.head.appendChild(output.stylesheet);
			*/
			add_latex_node_to_parent_promise(tex, input_wip_display).then(() => {
				scroll_to_bottom();
			});
        }

        function clear_wip_tex() {
            while (input_wip_display.firstChild) {
                input_wip_display.removeChild(input_wip_display.firstChild);
            }
            while (wip_stylesheets.length > 0) {
                var stylesheet = wip_stylesheets.shift();
                document.head.removeChild(stylesheet);
            }

        }

        function scroll_to_bottom() {
            document.scrollingElement.scrollTop = document.scrollingElement.scrollHeight;
        }

        function set_theme(theme) {
            console.debug("Setting theme to ", theme);
            var theme_classes = [
                "calc_light",
                "calc_dark",
            ];
            var css_class = "calc_light";
            switch(theme) {
                case "light":    css_class = "calc_light"; break;
                case "dark":     css_class = "calc_dark";  break;
                case "verydark": css_class = "calc_very_dark"; break;
                default: console.error("unexpected theme type", theme); break;
            }

            var style_elems = [
                document.getElementById("calc_body"),
                document.getElementById("output_text"),
                document.getElementById("input_wip_display"),
            ];

            for (var elem of style_elems) {
                for (var theme_class of theme_classes) {
                    elem.classList.remove(theme_class);
                }
                elem.classList.add(css_class);
            }
        }
</script>
</body>
</html>
